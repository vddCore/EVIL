using System.Collections.Generic;
using System.IO;
using EVIL.CVIL.Services;
using EVIL.CVIL.Utilities;
using EVIL.ExecutionEngine.Abstraction;
using EVIL.Grammar;
using EVIL.Intermediate.CodeGeneration;
using EVIL.Intermediate.Storage;
using EVIL.Lexical;
using Mono.Options;
using EvilProgram = EVIL.Grammar.AST.Nodes.Program;

namespace EVIL.CVIL
{
    internal static class Program
    {
        private static readonly ParserService _parserService = new();
        private static readonly CompilerService _compilerService = new();
        private static readonly DisassemblerService _disassemblerService = new();

        private static readonly OptionSet _options = new()
        {
            { "h|help", "Show this message.", _ => Workflow.ExitWithHelp(_options) },
            { "O|optimize", "Optimize generated bytecode.", _ => _compilerService.OptimizeBytecode = true },
            { "D|no-debug", "Don't emit debugging information.", _ => _compilerService.GenerateDebugInfo = false },
            { "d|disasm", "Print out disassembly of the generated code.", _ => _disassemblerService.Enabled = true },
            { "l|library", "Generate a library instead of an executable.", _ => _wantLibrary = true },
            { "o|output=", "Specify output file name", v => _outputFileName = v }
        };

        private static bool _wantLibrary;
        private static string _outputFileName;

        internal static void Main(string[] args)
        {
            var inputs = _options.Parse(args);

            if (inputs.Count <= 0)
            {
                Workflow.ExitWithMessage("no input files.", -1);
            }

            if (_outputFileName == null)
            {
                _outputFileName = _wantLibrary ? "a.evl" : "a.evx";
            }

            _parserService.AllowTopLevelStatements = !_wantLibrary;

            var objects = CompilePrograms(
                ParseSources(inputs)
            );

            if (_wantLibrary)
            {
                LinkLibrary(objects)
                .Serialize(_outputFileName);
            }
            else
            {
                EvxWriter.Write(
                    LinkExecutable(objects), 
                    _outputFileName
                );
            }
        }

        private static IEnumerable<(string, EvilProgram)> ParseSources(IEnumerable<string> sourceFiles)
        {
            var programs = new List<(string, EvilProgram)>();

            foreach (var fileName in sourceFiles)
            {
                if (!File.Exists(fileName))
                {
                    Workflow.ExitWithMessage($"file `{fileName}' does not exist.", -2);
                }

                try
                {
                    programs.Add(
                        (fileName, _parserService.Parse(fileName))
                    );

                    // When compiling executables, only allow
                    // top-level statements in the first file.
                    //
                    if (_parserService.AllowTopLevelStatements)
                    {
                        _parserService.AllowTopLevelStatements = false;
                    }
                }
                catch (IOException ioe)
                {
                    Workflow.ExitWithMessage($"unable to open {fileName}: {ioe.Message}");
                }
                catch (LexerException le)
                {
                    Workflow.ExitWithMessage($"`{fileName}' ({le.Line}:{le.Column}): {le.Message}");
                }
                catch (ParserException pe)
                {
                    Workflow.ExitWithMessage($"`{fileName}' ({pe.Line}:{pe.Column}): {pe.Message}");
                }
            }

            return programs;
        }

        private static IEnumerable<(string, Executable)> CompilePrograms(IEnumerable<(string, EvilProgram)> programs)
        {
            var executables = new List<(string, Executable)>();

            foreach (var (fileName, program) in programs)
            {
                try
                {
                    executables.Add(
                        (fileName, _compilerService.Compile(program))
                    );
                }
                catch (CompilerException ce)
                {
                    Workflow.ExitWithMessage($"`{fileName}' ({ce.Line}:{ce.Column}): {ce.Message}");
                }
            }

            return executables;
        }

        private static Executable LinkExecutable(IEnumerable<(string, Executable)> objects)
        {
            var exe = new Executable();
            var chunksSeen = new Dictionary<string, (string, Chunk)>();
            
            foreach (var (fileName, obj) in objects)
            {
                foreach (var chunk in obj.Chunks)
                {
                    if (chunk.IsRoot && exe.Chunks.Count == 0)
                    {
                        exe.Chunks.Add(chunk);
                        continue;
                    }

                    if (chunksSeen.TryGetValue(chunk.Name, out var tuple))
                    {
                        var (prevFileName, prevChunk) = tuple;
                        Workflow.ExitWithMessage($"`{fileName}': function '{chunk.Name}' (line {chunk.DefinedOnLine}) was already defined in `{prevFileName}' (line {prevChunk.DefinedOnLine}).");
                    }

                    exe.Chunks.Add(chunk);
                    chunksSeen.Add(chunk.Name, (fileName, chunk));
                }
            }

            _disassemblerService.Disassemble(exe.Chunks);
            return exe;
        }

        private static Table LinkLibrary(IEnumerable<(string, Executable)> objects)
        {
            var table = new Table();
            var exe = LinkExecutable(objects);

            foreach (var chunk in exe.Chunks)
            {
                if (chunk.IsRoot)
                    continue;

                table[chunk.Name] = new DynamicValue(chunk);
            }
            
            _disassemblerService.Disassemble(exe.Chunks);
            return table;
        }
    }
}